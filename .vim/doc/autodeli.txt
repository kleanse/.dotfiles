*autodeli.txt*	For Vim version 8.2	Last change: 2021 Nov 30

	      Automatically insert and delete matching delimiters

This document describes the functions defined in autodeli.vim and when
matching delimiters are completed and deleted automatically.

1.  Function list		    |autodeli-function-list|
2.  Function documentation	    |autodeli-functions|
3.  Technical details		    |autodeli-verbose|
    3.1 Functions			|autodeli-func-details|

==============================================================================
1.	Function list				*autodeli-function-list*

Auto-completion:				*autodeli-auto-functions*
	s:autocomplete_delimiters()	insert a pair of delimiters at once
	s:autocomplete_quotes()		insert a pair of quotes at once if the
					given quote is entered outside a
					string
	s:skip_closing()		skip a closing delimiter if no
					characters or only whitespace separate
					it and the cursor

Buffers:				*autodeli-buffer-functions*
	s:matched()			gets the matching delimiter of the
					delimiter at the given byte index

Overload:					*autodeli-overload-functions*
	s:autodeli_eat()		overload a backspace character for
					Insert mode
	s:autodeli_brace()		overload { for Insert mode
	s:autodeli_enter()		overload <CR> for Insert mode
	s:autodeli_tab()		overload <Tab> for Insert mode

==============================================================================
2.	Function documentation			*autodeli-functions*

See |autodeli-function-list| for a lexically ordered list of categories, each
of which contains functions sorted in the same fashion. Also see
|autodeli-func-details| for more comprehensive descriptions of certain
functions.

s:autocomplete_delimiters({opening}, {closing})	*s:autocomplete_delimiters()*
	Expects: type({opening}) == v:t_string
		 && type({closing}) == v:t_string
		 && len({opening}) == 1 && len({closing}) == 1
	Ensures: returns a string comprising characters to be interpreted by
		 the {rhs} of a mapping. This string effectively inserts
		 {opening} and {closing} simultaneously and positions the
		 cursor between them. The result is like typing three
		 characters: {opening}, then {closing}, and finally <Left>.
		 This function only works in Insert mode.

s:autocomplete_quotes({quote})			*s:autocomplete_quotes()*
	Expects: type({quote}) == v:t_string && len({quote}) == 1
	Ensures: returns a string comprising characters to be interpreted by
		 the {rhs} of a mapping. This string performs the same as that
		 of |s:autocomplete_delimiters()|, but specially handles
		 quotes: quotes are completed automatically if they are
		 entered outside a string and after a non-word character. If a
		 quote is entered when the cursor is in a string whose
		 delimiters match the quote, the string imitates
		 |s:skip_closing()| so long as the preceding character is not
		 a backslash. This function only works in Insert mode.

s:autodeli_eat({delchar})				*s:autodeli_eat()*
	Expects: type({delchar}) == v:t_string
	Ensures: returns a string comprising characters to be interpreted by
		 the {rhs} of a mapping. This string effectively deletes a
		 pair of delimiters when both the opening and closing
		 delimiters are immediately adjacent or separated by only
		 whitespace and the opening delimiter is the character being
		 deleted. Delimiters with the same opening and closing
		 notations are supported, i.e., quotes, but only delimiters
		 with different notations can be deleted across multiple
		 lines. This function only works in Insert mode.

		 {delchar} is the backspacing character to use in the return
		 string |i_backspacing|.

		 This function works iteratively if {delchar} is CTRL-U or
		 CTRL-W: matching opening delimiters being deleted will also
		 delete their respective closing delimiters so long as no
		 characters or only whitespace separate the closing
		 delimiters. For example, if no new characters are entered and
		 'backspace' contains "start", entering CTRL-U, where the
		 cursor is denoted by @,
			(((@)))
		 results in
			@

s:autodeli_brace()				*s:autodeli_brace()*
	Expects: none
	Ensures: returns a string comprising characters to be interpreted by
		 the {rhs} of a mapping. This string executes the behavior of
		 entering an opening brace |autodeli-func-details|. This
		 function only works in Insert mode.

s:autodeli_enter()				*s:autodeli_enter()*
	Expects: none
	Ensures: returns a string comprising characters to be interpreted by
		 the {rhs} of a mapping. This string fulfills the second
		 outcome of auto-completing braces |autodeli-func-details|.
		 This function only works in Insert mode.

s:autodeli_tab()				*s:autodeli_tab()*
	Expects: none
	Ensures: returns a string comprising characters to be interpreted by
		 the {rhs} of a mapping. This string effectively moves the
		 cursor past the closing delimiter of the innermost pair of
		 delimiters surrounding the cursor if no characters or only
		 whitespace separate the cursor and closing delimiter.
		 Otherwise, it inserts a <Tab>. This function only works in
		 Insert mode.

s:matched({index} [, {lnum}])				*s:matched()*
	Expects: type({index}) == v:t_number
		 && 0 <= {index} < strlen(getline{lnum})
		 Optional parameters:
		 type({lnum}) == v:t_number
		 && 1 <= {lnum} <= line('$')
	Ensures: returns a List containing the position of the delimiter
		 matching that found at byte index {index} on the line
		 indicated by {lnum}. By default, {lnum} is the cursor's line
		 number. If the delimiter to consider is not a valid delimiter
		 or no matching delimiter is found, returns [0, 0].
			Index	Meaning
			0	line number
			1	column number

s:skip_closing({closing})			*s:skip_closing()*
	Expects: type({closing}) == v:t_string && len({closing}) == 1
		 && {closing} is in the List of valid delimiters.
	Ensures: returns a string comprising characters to be interpreted by
		 the {rhs} of a mapping. This string executes the behavior of
		 entering {closing} when the cursor is between the delimiters
		 that include {closing} |autodeli-closing-delim|. This
		 function only works in Insert mode.

==============================================================================
3.	Technical details			*autodeli-verbose*

INSERTING DELIMITERS

A pair of matching delimiters eligible for autocompletion is inserted when the
opening delimiter is entered.

UNDO COMPLETION

An automatically completed pair of delimiters is not considered a separate
change; it is part of the current Insert command. Thus, undoing an
auto-completed pair undoes the entire Insert command, which is the default Vim
behavior.

Parentheses and Brackets ~

Parentheses and brackets are always completed automatically.

Quotes ~

In most cases, quotation marks are completed automatically. However, if a
quote is entered within a string or immediately after a word character, it is
not completed (assuming that the string is delimited by different quotes
|autodeli-closing-delim|): typing a ' or " inserts the respective character
as normal.

Strings ~
						*autodeli-string*
In this plugin's context, a string is defined to be a sequence of characters
delimited by either single quotes or double quotes, where the opening quote
succeeds the start of line or a non-word character. Strings cannot be nested,
and they cannot span across multiple lines. Instances of the quote delimiting
a string can be used within the same string so long as they are escaped with
backslashes. Quotes within a string delimited by the alternative quotes have
no special meaning, regardless of whether they are escaped.

Unlike quotes, all other valid delimiters retain their special meanings in a
string with a couple of caveats: an opening non-quote delimiter can match its
closing delimiter so long as both delimiters reside in the same string and are
unescaped.
Examples:
	( "" )	Parentheses match
	'('  )	No match; thus, closing parenthesis cannot be skipped.
	"(foo)"	Parentheses match

Braces ~

Braces behave like parentheses: they are always completed automatically.
However, braces have two special cases: one case regarding the <CR> character,
and the other case if '{' is entered on an empty line.

If a <CR> is entered immediately after an opening brace, the cursor begins at
one additional indent level on the new line, and the closing brace moves to
another line, indented at the same level as the line of the opening brace.
That is, entering a <CR>, where the cursor is indicated as an @

	if (condition) {@}

produces

	if (condition) {
		@
	}

If a '{' is entered on an empty line, the above behavior occurs immediately.
So, entering '{'

	@

yields

	{
		@
	}

Entering isolated opening delimiters ~
						*autodeli-no-complete*
Under this plugin, an auto-completing opening delimiter can be entered by
itself by pressing its corresponding key as normal, moving the cursor after
the automatically inserted closing delimiter, and deleting the closing
delimiter. Alternatively, after the delimiter pair is inserted automatically,
type "<C-O>x".

Entering a closing delimiter or <Tab> ~
						*autodeli-closing-delim*
When the closing delimiter of the set of delimiters surrounding the cursor is
entered, the existing closing delimiter moves to the cursor and the cursor
advances past this delimiter. This behavior occurs so long as no characters or
only whitespace lie between the cursor and the closing delimiter. For
delimiters with different opening and closing notations, it works across
lines, e.g., entering '}' where @ indicates the cursor

	{
		@
	}

yields

	{
		}@

Entering a <Tab> in the same context as detailed above results in a similar
behavior, i.e., the cursor advances past the closing delimiter, but the
closing delimiter stays in its original position. The visible difference
between this behavior and the previous one is the whitespace between the
cursor and the closing delimiter: the former behavior preserves it, while the
latter one deletes it. Additionally, this behavior only works if the matching
delimiters are on the same line, but they need not different notations.


3.1 Functions ~
						*autodeli-func-details*
This section contains further descriptions of some of the functions listed in
|autodeli-function-list|. These functions with their accompanying
descriptions are lexically ordered. For an overview of them, see
|autodeli-functions|.


s:autodeli_eat()

This function provides quick deletion of a matching pair. If the first
non-whitespace character following the cursor is a matched closing delimiter
and the corresponding opening delimiter would normally be deleted by the given
backspacing character, the closing delimiter and whitespace between it and the
cursor are deleted as well. This function overloads <BS>, CTRL-U, and CTRL-W
in Insert mode.

The <BS> character behaves as normal in all modes except for Insert mode. In
Insert mode, deleting a valid opening delimiter also deletes its matching
closing delimiter if the delimiters are immediately adjacent to one another or
separated by only whitespace. Otherwise, <BS> is interpreted as normal.

This function works across multiple lines. Delimiters that have the same
notation for their opening and closing versions are supported, but the
matching delimiters must be on the same line; such an intricacy is similar to
that of the behavior produced by entering a closing delimiter
|autodeli-closing-delim|.

Examples, where @ indicates the cursor position:

	start {@

	} trailing text

Entering a backslash here yields

	start @ trailing text

With quotes, the following text

	print "@   "

becomes

	print @

The overloaded <BS> has one more intricacy: when deleting a brace pair, if the
closing brace is immediately followed by a semicolon, the semicolon is deleted
as well: entering a <BS>

	struct {@
	};

produces

	struct @


s:autodeli_brace()

Out of all the auto-completing delimiters, braces are the most special:
entering an '{' can result in one of three outcomes, listed from highest to
lowest priority:

	1. The '{' expands into three lines: first contains the opening brace;
	   second is indented by the current primary indent option
	   |C-indenting|; and third contains a closing brace indented at the
	   same level as the first so long as at least 'autoindent' is set.
	   The cursor is positioned at the end of the second line.
	2. Like the first outcome, but occurs after a subsequent <CR> is
	   entered.
	3. The '{' is auto-completed like parentheses and brackets.

The first and last outcomes occur as soon as '{' is entered; the second
outcome occurs when <CR> is entered and the cursor is surrounded by braces. Of
course, if the first outcome always triggered when '{' is entered, this second
outcome would be permanently hidden. Therefore, the first outcome has one
further stipulation: the line must be empty or comprise only whitespace when
'{' is entered; if the line has whitespace, any whitespace after '{' is
deleted, and whitespace before '{' is preserved.

The indentation levels of the subsequent two lines in the first outcome is
governed by the options 'autoindent', 'smartindent', 'cindent', and
'indentexpr'. If only 'autoindent' is set, both the second and third lines'
indents match that of the first line. If any of the other three options is set
or nonempty, the principal option dictates the indent style of the second and
third lines (see |C-indenting| for the option ranking). If none of these four
options are set or nonempty, no indent is provided for the second and third
lines: they are flush left.

The second outcome typically occurs when typing <CR> after entering a '{'.
However, it actually can occur anytime a <CR> is entered between a '{' and a
'}', where '{' and '}' may be separated by whitespace. In the case where
whitespace precedes '}', whitespace between the '{' and the cursor is deleted.
Whitespace between the cursor and '}' is also usually deleted; the exception
is when neither 'autoindent', 'smartindent', 'cindent', nor 'indentexpr' is
set or nonempty. For example, with 'autoindent' set, entering a <CR>, where
the cursor is indicated as an @

		       whitespace
			vv vvv v
	if (condition) {  @   } trailing

yields

	if (condition) {
	@
	} trailing

Without 'autoindent', the result is

	if (condition) {
	@
	   } trailing

Besides the three outcomes, braces have one more automated aspect: entering an
'{' on a line that begins with the word "struct", "class", or "enum"
automatically inserts a semicolon after the brace pair.


s:matched()

s:matched() does the heavy lifting in this plugin: it checks whether the given
delimiter is matched according to the rules described in this document. The
return value is a position, which comprises a line number and column number.

If the delimiter to consider is a quote or in a string, this function returns
the position of the matching unescaped delimiter on the same line and in the
same string. Otherwise, if it is a valid delimiter, the function returns the
position of the matching delimiter, which may reside on a different line.

To limit search time, only the lines within the current window's view are
considered. Thus, if the given delimiter actually has a matching delimiter but
it is not in view, this function misleadingly reports the delimiter as
unmatched.

 vim:tw=78:isk=!-~,^*,^\|,^\":ts=8:noet:ft=help:norl:
